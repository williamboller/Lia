<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
  <title>Countdown to Lia</title>

  <meta name="theme-color" content="#160a3a" id="themeColorMeta">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Countdown ‚ù§Ô∏è">

  <link rel="icon" type="image/svg+xml"
        href='data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">‚ù§Ô∏è</text></svg>'>

  <link rel="apple-touch-icon" href="apple-touch-icon.png">
  <link rel="manifest" href="manifest.webmanifest">

  <style>
    :root{
      --bg1:#160a3a;
      --bg2:#12072d;

      --text:#eef0ff;
      --muted:#c7c2e6;

      --shadow: 0 20px 60px rgba(0,0,0,.35);
      --stroke: rgba(255,255,255,.10);
      --card: rgba(20, 14, 46, .78);

      --accent2: rgba(190,120,255,.24);
      --accent3: rgba(120,160,255,.14);
    }

    *{ box-sizing:border-box; }

    html, body{
      height:100%;
      background: var(--bg1);
    }

    body{
      margin:0;
      min-height:100svh;
      display:flex;
      align-items:flex-start;
      justify-content:center;
      padding:
        max(18px, env(safe-area-inset-top))
        16px
        max(18px, env(safe-area-inset-bottom));

      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;

      background:
        radial-gradient(900px 500px at 15% 20%, var(--accent2), transparent 60%),
        radial-gradient(900px 500px at 85% 80%, var(--accent3), transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg2));

      transition: background 600ms ease, color 400ms ease;
      overflow-x:hidden;
      -webkit-font-smoothing: antialiased;
    }

    #stars{
      position: fixed;
      inset: 0;
      z-index: 0;
      pointer-events: none;
      opacity: .30;
    }

    .wrap{
      width:min(980px, 100%);
      text-align:center;
      position: relative;
      z-index: 1;
      margin-top: 8px;
    }

    .tabs{
      display:flex;
      gap:10px;
      justify-content:center;
      margin-bottom:14px;
      flex-wrap:wrap;
    }
    .tab{
      appearance:none;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: rgba(234,240,255,.9);
      padding: 10px 14px;
      border-radius: 999px;
      font-weight: 800;
      letter-spacing: -0.01em;
      cursor: pointer;
      transition: transform .12s ease, background .2s ease, border-color .2s ease;
    }
    .tab:hover{ transform: translateY(-1px); }
    .tab.active{
      background: rgba(190,120,255,.16);
      border-color: rgba(190,120,255,.38);
      color: rgba(234,240,255,1);
    }

    .card{
      background: var(--card);
      border: 1px solid var(--stroke);
      border-radius: 28px;
      padding: 44px 22px 36px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }

    h1{
      margin:0 0 12px;
      font-size: clamp(34px, 5vw, 72px);
      font-weight:900;
      letter-spacing: -0.02em;
    }

    .rotator{
      margin: 14px 0 8px;
      min-height: 20px;
      font-size: 15px;
      color: rgba(234,240,255,.92);
      opacity: .92;
      font-weight: 700;
      transition: opacity 240ms ease, transform 240ms ease;
      transform: translateY(0);
    }
    .rotator.fadeOut{ opacity: 0; transform: translateY(6px); }
    .rotator.fadeIn{ opacity: .92; transform: translateY(0); }

    .sub{
      font-size: 22px;
      color: var(--muted);
      margin-bottom: 8px;
      font-weight: 750;
    }

    .milestone{
      margin: 0 0 14px;
      font-size: 15px;
      color: rgba(234,240,255,.9);
      opacity: .95;
      font-weight: 750;
      min-height: 20px;
    }

    .countGrid{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap:12px;
      margin: 12px auto 10px;
      padding:14px;
      border-radius:18px;
      background: rgba(190,120,255,.07);
      border:1px solid rgba(190,120,255,.20);
      transition: background 500ms ease, border-color 500ms ease;
    }

    .unit{
      padding:14px;
      border-radius:16px;
      background: rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.09);
      position: relative;
      overflow: hidden;
      transition: transform 180ms ease, border-color 500ms ease, box-shadow 500ms ease, background 500ms ease;
    }

    .num{
      font-size: 38px;
      font-weight:900;
      display:inline-block;
      transition: transform 180ms ease, opacity 180ms ease;
      will-change: transform, opacity;
    }
    .num.bump{ transform: translateY(-6px) scale(1.03); opacity: .92; }

    .lbl{
      margin-top:6px;
      font-size:13px;
      color:var(--muted);
      text-transform:uppercase;
      letter-spacing:.1em;
      font-weight: 800;
    }

    .unit.clickable{ cursor:pointer; }
    .unit.clickable:hover{ transform: translateY(-2px); }

    .unit.seconds{
      border-color: rgba(190,120,255,.32);
      box-shadow: 0 0 0 rgba(190,120,255,0);
    }
    .unit.seconds::before{
      content:"";
      position:absolute;
      inset:-40%;
      background: radial-gradient(circle at 50% 50%, rgba(190,120,255,.38), transparent 55%);
      opacity:.20;
      animation: glowPulse 1.6s ease-in-out infinite;
      pointer-events:none;
    }
    .unit.seconds::after{
      content:"";
      position:absolute;
      inset:0;
      border-radius:16px;
      box-shadow: 0 0 22px rgba(190,120,255,.18);
      opacity:.35;
      animation: glowRing 1.6s ease-in-out infinite;
      pointer-events:none;
    }
    @keyframes glowPulse{
      0%,100%{ transform: scale(.94); opacity:.18; }
      50%{ transform: scale(1.02); opacity:.30; }
    }
    @keyframes glowRing{
      0%,100%{ opacity:.22; }
      50%{ opacity:.42; }
    }

    .hint{ display:none; }

    .sectionTitle{
      font-size:32px;
      margin: 18px 0 14px;
      font-weight:900;
      letter-spacing: -0.02em;
    }

    .statsGrid{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:12px;
    }

    .statCard{
      padding:16px;
      border-radius:18px;
      background: rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.09);
    }

    .statLabel{
      font-size:13px;
      color:var(--muted);
      letter-spacing:.1em;
      text-transform:uppercase;
      margin-bottom:6px;
      font-weight: 800;
    }

    .statValue{
      font-size:28px;
      font-weight:900;
      letter-spacing: -0.02em;
      display:inline-block;
      transition: transform 180ms ease, opacity 180ms ease;
      will-change: transform, opacity;
    }
    .statValue.bump{ transform: translateY(-4px) scale(1.01); opacity: .92; }

    .soon{
      margin-top: 18px;
      font-size:16px;
      opacity:.9;
      font-weight: 800;
    }

    .panel{ display:none; }
    .panel.active{ display:block; }

    .modalOverlay{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.55);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
      z-index: 9999;
      backdrop-filter: blur(6px);
    }
    .modalOverlay.show{ display:flex; }

    .modal{
      width: min(540px, 100%);
      border-radius: 20px;
      background: rgba(20, 14, 46, .92);
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: 0 30px 80px rgba(0,0,0,.45);
      padding: 18px 18px 14px;
      text-align: left;
      position: relative;
    }
    .modal h3{
      margin: 2px 0 10px;
      font-size: 18px;
      letter-spacing: -0.01em;
    }
    .modal p{
      margin: 0 0 12px;
      color: rgba(234,240,255,.92);
      line-height: 1.35;
      font-size: 15px;
    }
    .modal .x{
      position:absolute;
      top: 10px;
      right: 10px;
      width: 38px;
      height: 38px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(234,240,255,.9);
      font-size: 18px;
      font-weight: 900;
      cursor: pointer;
    }
    .modal .x:hover{
      background: rgba(190,120,255,.18);
      border-color: rgba(190,120,255,.35);
    }

    @media (max-width:720px){
      .countGrid{ grid-template-columns: repeat(2,1fr); }
      .statsGrid{ grid-template-columns: 1fr; }
    }
  </style>
</head>

<body>
  <canvas id="stars"></canvas>

  <div class="wrap">
    <div class="tabs" role="tablist" aria-label="Countdown tabs">
      <button class="tab active" id="tabCountdown" type="button">Until</button>
      <button class="tab" id="tabSince" type="button">Since</button>
    </div>

    <div class="panel active" id="panelCountdown">
      <div class="card">
        <h1>Will Sees Lia</h1>

        <div class="sub">In</div>
        <div class="milestone" id="milestoneCountdown"></div>

        <div class="countGrid">
          <div class="unit"><div class="num" id="d">‚Äî</div><div class="lbl" id="dLbl">Days</div></div>
          <div class="unit"><div class="num" id="h">‚Äî</div><div class="lbl" id="hLbl">Hours</div></div>
          <div class="unit"><div class="num" id="m">‚Äî</div><div class="lbl" id="mLbl">Minutes</div></div>

          <div class="unit seconds clickable" id="secondsBox">
            <div class="num" id="s">‚Äî</div>
            <div class="lbl" id="sLbl">Seconds</div>
          </div>
        </div>

        <div class="rotator" id="rotatorCountdown"></div>

        <div class="sectionTitle">That‚Äôs</div>

        <div class="statsGrid">
          <div class="statCard">
            <div class="statLabel">Total Hours</div>
            <div class="statValue" id="th">‚Äî</div>
          </div>
          <div class="statCard">
            <div class="statLabel">Total Minutes</div>
            <div class="statValue" id="tm">‚Äî</div>
          </div>
          <div class="statCard">
            <div class="statLabel">Total Seconds</div>
            <div class="statValue" id="ts">‚Äî</div>
          </div>
        </div>
      </div>

      <div class="soon">See you soon ‚ù§Ô∏è</div>
    </div>

    <div class="panel" id="panelSince">
      <div class="card">
        <h1>We Saw Each Other</h1>

        <div class="rotator" id="rotatorSince"></div>
        <div class="sub">Since 12/19/2025 ‚Ä¢ 4:20 PM ET</div>

        <div class="milestone" id="milestoneSince"></div>

        <div class="countGrid">
          <div class="unit"><div class="num" id="sd">‚Äî</div><div class="lbl" id="sdLbl">Days</div></div>
          <div class="unit"><div class="num" id="sh">‚Äî</div><div class="lbl" id="shLbl">Hours</div></div>
          <div class="unit"><div class="num" id="sm">‚Äî</div><div class="lbl" id="smLbl">Minutes</div></div>
          <div class="unit"><div class="num" id="ss">‚Äî</div><div class="lbl" id="ssLbl">Seconds</div></div>
        </div>

        <div class="sectionTitle">That‚Äôs</div>

        <div class="statsGrid">
          <div class="statCard">
            <div class="statLabel">Total Hours</div>
            <div class="statValue" id="sth">‚Äî</div>
          </div>
          <div class="statCard">
            <div class="statLabel">Total Minutes</div>
            <div class="statValue" id="stm">‚Äî</div>
          </div>
          <div class="statCard">
            <div class="statLabel">Total Seconds</div>
            <div class="statValue" id="sts">‚Äî</div>
          </div>
        </div>
      </div>

      <div class="soon">One day closer ‚ù§Ô∏è</div>
    </div>
  </div>

  <div class="modalOverlay" id="modalOverlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <button class="x" id="modalClose" aria-label="Close">‚úï</button>
      <h3 id="modalTitle">Fun fact</h3>
      <p id="modalText">Loading‚Ä¶</p>
    </div>
  </div>

  <script>
    const TARGET = Date.UTC(2026,0,4,17,0,0);
    const SINCE  = Date.UTC(2025,11,19,21,20,0);

    const d=document.getElementById("d"),
          h=document.getElementById("h"),
          m=document.getElementById("m"),
          s=document.getElementById("s"),
          th=document.getElementById("th"),
          tm=document.getElementById("tm"),
          ts=document.getElementById("ts");

    const dLbl=document.getElementById("dLbl"),
          hLbl=document.getElementById("hLbl"),
          mLbl=document.getElementById("mLbl"),
          sLbl=document.getElementById("sLbl");

    const milestoneCountdown = document.getElementById("milestoneCountdown");
    const rotatorCountdown = document.getElementById("rotatorCountdown");
    const secondsBox = document.getElementById("secondsBox");

    const sd=document.getElementById("sd"),
          sh=document.getElementById("sh"),
          sm=document.getElementById("sm"),
          ss=document.getElementById("ss"),
          sth=document.getElementById("sth"),
          stm=document.getElementById("stm"),
          sts=document.getElementById("sts");

    const sdLbl=document.getElementById("sdLbl"),
          shLbl=document.getElementById("shLbl"),
          smLbl=document.getElementById("smLbl"),
          ssLbl=document.getElementById("ssLbl");

    const milestoneSince = document.getElementById("milestoneSince");
    const rotatorSince = document.getElementById("rotatorSince");

    const tabCountdown = document.getElementById("tabCountdown");
    const tabSince = document.getElementById("tabSince");
    const panelCountdown = document.getElementById("panelCountdown");
    const panelSince = document.getElementById("panelSince");

    tabCountdown.addEventListener("click", () => {
      tabCountdown.classList.add("active");
      tabSince.classList.remove("active");
      panelCountdown.classList.add("active");
      panelSince.classList.remove("active");
    });

    tabSince.addEventListener("click", () => {
      tabSince.classList.add("active");
      tabCountdown.classList.remove("active");
      panelSince.classList.add("active");
      panelCountdown.classList.remove("active");
    });

    const modalOverlay = document.getElementById("modalOverlay");
    const modalClose = document.getElementById("modalClose");
    const modalText = document.getElementById("modalText");

    function openModal(text){
      modalText.textContent = text;
      modalOverlay.classList.add("show");
      modalOverlay.setAttribute("aria-hidden","false");
    }
    function closeModal(){
      modalOverlay.classList.remove("show");
      modalOverlay.setAttribute("aria-hidden","true");
    }
    modalClose.addEventListener("click", closeModal);
    modalOverlay.addEventListener("click", (e) => { if (e.target === modalOverlay) closeModal(); });
    document.addEventListener("keydown", (e) => { if (e.key === "Escape") closeModal(); });

    const pad=n=>String(n).padStart(2,"0");
    const fmt=n=>n.toLocaleString("en-US");
    const plural=(n, one, many)=> (n===1 ? one : many);

    function bump(el){
      el.classList.remove("bump");
      void el.offsetWidth;
      el.classList.add("bump");
      setTimeout(() => el.classList.remove("bump"), 190);
    }

    function setText(el, v){
      if (el.textContent !== v){
        el.textContent = v;
        bump(el);
      }
    }

    function applyTheme(secondsRemaining){
      const hour = new Date().getHours();
      const isDay = (hour >= 8 && hour < 18);

      let bg1 = isDay ? "#1a0b45" : "#120738";
      let bg2 = isDay ? "#120736" : "#0b0524";

      let a2 = "rgba(190,120,255,.26)";
      let a3 = "rgba(120,160,255,.14)";
      let borderHot = "rgba(190,120,255,.20)";

      if (secondsRemaining <= 3600 * 24){
        a2 = "rgba(255,120,200,.22)";
        a3 = "rgba(255,170,120,.14)";
        borderHot = "rgba(255,120,200,.22)";
      } else if (secondsRemaining <= 3600 * 24 * 7){
        a2 = "rgba(160,255,210,.18)";
        a3 = "rgba(190,120,255,.12)";
        borderHot = "rgba(160,255,210,.20)";
      }

      document.documentElement.style.setProperty("--bg1", bg1);
      document.documentElement.style.setProperty("--bg2", bg2);
      document.documentElement.style.setProperty("--accent2", a2);
      document.documentElement.style.setProperty("--accent3", a3);

      const meta = document.getElementById("themeColorMeta");
      if (meta) meta.setAttribute("content", bg1);

      document.querySelectorAll(".countGrid").forEach(g => g.style.borderColor = borderHot);
    }

    function milestoneText(secondsRemaining){
      if (secondsRemaining <= 0) return "It‚Äôs time. ‚ù§Ô∏è";
      if (secondsRemaining <= 10) return "Ten seconds.";
      if (secondsRemaining <= 60) return "Less than a minute.";
      if (secondsRemaining <= 60 * 5) return "Five minutes or less.";
      if (secondsRemaining <= 60 * 30) return "Under 30 minutes.";
      if (secondsRemaining <= 3600) return "Less than an hour.";
      if (secondsRemaining <= 3600 * 6) return "Today.";
      if (secondsRemaining <= 3600 * 24) return "Tomorrow.";
      if (secondsRemaining <= 3600 * 24 * 2) return "Two days.";
      if (secondsRemaining <= 3600 * 24 * 3) return "Three days.";
      if (secondsRemaining <= 3600 * 24 * 7) return "One week.";
      return "Counting down‚Ä¶";
    }

    function milestoneTextSince(totalSeconds){
      if (totalSeconds < 30) return "Just now.";
      if (totalSeconds < 60) return "Less than a minute.";
      if (totalSeconds < 60 * 10) return "A few minutes ago.";
      if (totalSeconds < 3600) return "Less than an hour ago.";
      if (totalSeconds < 3600 * 6) return "Earlier today.";
      if (totalSeconds < 3600 * 24) return "Today.";
      if (totalSeconds < 3600 * 48) return "Yesterday.";
      return "Time keeps moving‚Ä¶";
    }

    const rotateCountdownLines = [
      "Every second closer.",
      "Worth the wait ‚ù§Ô∏è",
      "Don‚Äôt blink.",
      "Quietly counting down‚Ä¶",
      "Almost there (soon).",
      "This is the part where time crawls üò≠",
      "Okay‚Ä¶ okay‚Ä¶ okay‚Ä¶",
    ];

    const rotateSinceLines = [
      "Time since that moment.",
      "Still thinking about it.",
      "Feels longer than it is.",
      "Counting up until the next one.",
      "Time moves‚Ä¶ but not fast enough.",
    ];

    function startRotator(el, lines){
      let idx = Math.floor(Math.random() * lines.length);
      el.textContent = lines[idx];

      setInterval(() => {
        el.classList.add("fadeOut");
        setTimeout(() => {
          idx = (idx + 1) % lines.length;
          el.textContent = lines[idx];
          el.classList.remove("fadeOut");
          el.classList.add("fadeIn");
          setTimeout(() => el.classList.remove("fadeIn"), 260);
        }, 260);
      }, 7000);
    }

    // -------------------------------------------------------
    // Time-based "fun facts" (NO duplicates per session)
    // - all facts are derived from time remaining (sec)
    // - avoids boring "that's X minutes/hours" statements
    // - 80-100+ unique-ish lines via template expansion
    // -------------------------------------------------------
    const seenFacts = new Set();

    function compactTime(sec){
      const days = Math.floor(sec / 86400);
      const hrs  = Math.floor((sec % 86400) / 3600);
      const mins = Math.floor((sec % 3600) / 60);

      if (sec <= 0) return "now";
      if (days > 0 && hrs > 0) return `${days}d ${hrs}h`;
      if (days > 0) return `${days}d`;
      if (hrs > 0 && mins > 0) return `${hrs}h ${mins}m`;
      if (hrs > 0) return `${hrs}h`;
      if (mins > 0) return `${mins}m`;
      return `${sec}s`;
    }

    function nextHourBoundarySeconds(sec){
      return sec % 3600;
    }

    function nextDayBoundarySeconds(sec){
      return sec % 86400;
    }

    function buildTimeFacts(sec){
      // If time is up
      if (sec <= 0){
        return [
          "Zero seconds left. ‚ù§Ô∏è",
          "No countdown anymore ‚Äî it‚Äôs happening.",
          "The wait is over."
        ];
      }

      const days = Math.floor(sec / 86400);
      const hrs  = Math.floor((sec % 86400) / 3600);
      const mins = Math.floor((sec % 3600) / 60);
      const secs = sec % 60;

      const totalHours = Math.floor(sec / 3600);
      const totalDays  = Math.floor(sec / 86400);

      const pctDay = Math.min(100, Math.max(0, Math.round((1 - (sec % 86400) / 86400) * 100)));
      const pctHour = Math.min(100, Math.max(0, Math.round((1 - (sec % 3600) / 3600) * 100)));

      const toNextHour = nextHourBoundarySeconds(sec);
      const toNextDay  = nextDayBoundarySeconds(sec);

      // "Reality" conversions (common relatable time slices)
      const songs3 = Math.floor(sec / 180);
      const eps22 = Math.floor(sec / (22 * 60));
      const showers8 = Math.floor(sec / (8 * 60));
      const tikTok30 = Math.floor(sec / 30);
      const commutes15 = Math.floor(sec / (15 * 60));
      const naps20 = Math.floor(sec / (20 * 60));
      const meals30 = Math.floor(sec / (30 * 60));
      const classes45 = Math.floor(sec / (45 * 60));
      const movies90 = Math.floor(sec / (90 * 60));

      const timeStr = compactTime(sec);

      // Templates ‚Äì all explicitly tied to sec
      const facts = [
        `If you press a stopwatch‚Ä¶ it would need to run for ${timeStr}.`,
        `That‚Äôs ${pctHour}% of the current hour already gone (until the next hour mark).`,
        `That‚Äôs ${pctDay}% of today‚Äôs ‚Äúlast day block‚Äù already burned.`,
        `There are ${fmt(totalHours)} full hours still inside this wait.`,
        `There are ${fmt(totalDays)} full days still inside this wait.`,
        `Next hour mark in ${compactTime(toNextHour)}.`,
        `Next day mark in ${compactTime(toNextDay)}.`,
        `You could listen to about ${fmt(songs3)} three-minute songs before time‚Äôs up.`,
        `You could watch about ${fmt(eps22)} 22-minute episodes before time‚Äôs up.`,
        `You could take about ${fmt(showers8)} quick 8-minute showers in the time left.`,
        `That‚Äôs enough time for about ${fmt(naps20)} ‚Äú20-minute nap‚Äù resets.`,
        `That‚Äôs enough time for about ${fmt(commutes15)} 15-minute drives.`,
        `If a TikTok is ~30 seconds, that‚Äôs about ${fmt(tikTok30)} TikToks long.`,
        `If a meal takes ~30 minutes, that‚Äôs about ${fmt(meals30)} meals worth of time.`,
        `If a class period is ~45 minutes, that‚Äôs about ${fmt(classes45)} class periods.`,
        `If a movie is ~90 minutes, that‚Äôs about ${fmt(movies90)} movies.`,
        `If you counted ‚Äúone Mississippi‚Äù once per second‚Ä¶ you‚Äôd say it ${fmt(sec)} times.`,
        `There are ${fmt(Math.floor(sec/60))} full minute-changes left on the clock.`,
        `There are ${fmt(Math.floor(sec/10))} ‚Äúten-second jumps‚Äù left.`,
        `There are ${fmt(Math.floor(sec/5))} ‚Äúfive-second jumps‚Äù left.`,
        `There are ${fmt(Math.floor(sec/2))} ‚Äútwo-second jumps‚Äù left.`,
        `You‚Äôre closer than you were 10,000 seconds ago ‚Äî by exactly 10,000 seconds.`,
        `Right now it‚Äôs ${days} days, ${hrs} hours, ${mins} minutes, ${secs} seconds.`,
        `This wait fits inside ${fmt(totalHours)} hourly blocks.`,
        `This wait fits inside ${fmt(totalDays)} daily blocks.`,
        `If you did a 60-second plank once per hour, you‚Äôd still have ${fmt(totalHours)} chances.`,
        `If you did 10 pushups per minute, that‚Äôs ${fmt(Math.floor(sec/60)*10)} pushups worth of minutes.`,
        `If you texted one word every second, that‚Äôs ${fmt(sec)} words worth of time.`,
        `If you blink ~15 times per minute, that‚Äôs about ${fmt(Math.floor(sec/60)*15)} blinks left.`,
        `If you breathe ~1 time every 4 seconds, that‚Äôs about ${fmt(Math.floor(sec/4))} breaths.`,
        `If your heart beats ~1.2 times per second, that‚Äôs about ${fmt(Math.floor(sec*1.2))} heartbeats. ‚ù§Ô∏è`,
        `If you walk 1 step per second, that‚Äôs about ${fmt(sec)} steps.`,
        `If a song chorus is ~40 seconds, that‚Äôs about ${fmt(Math.floor(sec/40))} choruses.`,
        `If you microwave something for 2 minutes, that‚Äôs ${fmt(Math.floor(sec/120))} microwaves long.`,
        `If you brush your teeth for 2 minutes, that‚Äôs ${fmt(Math.floor(sec/120))} tooth-brush sessions.`,
        `If you take a 10-minute break, that‚Äôs ${fmt(Math.floor(sec/600))} breaks.`,
        `If you send one Snap a minute, that‚Äôs ${fmt(Math.floor(sec/60))} Snaps worth of time.`,
        `If you scroll for 5 minutes‚Ä¶ that‚Äôs ${fmt(Math.floor(sec/300))} ‚Äú5-minute scrolls.‚Äù`,
        `If you do a 1-minute timer, you could run it ${fmt(Math.floor(sec/60))} times.`,
        `If you do a 10-second countdown, you could do it ${fmt(Math.floor(sec/10))} times.`,
        `There are ${fmt(Math.floor(sec/3600))} full hour flips still coming.`,
        `There are ${fmt(Math.floor(sec/86400))} full day flips still coming.`,
        `Next ‚Äú:00‚Äù on the minutes in ${compactTime(sec % 60)}.`,
        `Next ‚Äú:00‚Äù on the hours in ${compactTime(toNextHour)}.`,
      ];

      // Add a few time-conditional lines (more variety)
      if (sec < 60){
        facts.push(
          "It‚Äôs officially in the ‚Äúdon‚Äôt blink‚Äù zone.",
          "This is shorter than most songs."
        );
      }
      if (sec >= 60 && sec < 3600){
        facts.push(
          "This whole wait fits inside a single hour.",
          `It‚Äôs less than ${fmt(60 - Math.ceil((sec % 3600)/60))} minutes from the next hour mark.`
        );
      }
      if (sec >= 3600 && sec < 86400){
        facts.push(
          "This wait fits inside one day.",
          `If you sleep 8 hours, that‚Äôs ${fmt(Math.floor(sec/(8*3600)))} full 8-hour sleeps.`
        );
      }
      if (sec >= 86400){
        facts.push(
          `If you sleep 8 hours per day, there are about ${fmt(Math.floor(sec/(8*3600)))} sleeps left.`,
          `If you think in weekends, that‚Äôs about ${fmt(Math.floor(sec/(7*86400)))} weeks.`
        );
      }

      return facts;
    }

    function shuffle(arr){
      for (let i = arr.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    // We rebuild the deck each click based on current remaining seconds,
    // but still avoid duplicates per session using seenFacts.
    function nextTimeFact(sec){
      const pool = shuffle(buildTimeFacts(sec).slice());

      for (const fact of pool){
        if (!seenFacts.has(fact)){
          seenFacts.add(fact);
          return fact;
        }
      }

      // If we somehow exhausted all current-time templates, allow repeats (but try a rebuild first)
      seenFacts.clear();
      const pool2 = shuffle(buildTimeFacts(sec).slice());
      return pool2[0] || "Time fact loading‚Ä¶";
    }

    let lastRemainingSeconds = 0;

    secondsBox.addEventListener("click", () => {
      openModal(nextTimeFact(lastRemainingSeconds));
    });

    function tickCountdown(){
      let diff = TARGET - Date.now();
      if(diff < 0) diff = 0;

      const sec = Math.floor(diff/1000);
      lastRemainingSeconds = sec;

      const days=Math.floor(sec/86400);
      const hrs=Math.floor((sec%86400)/3600);
      const mins=Math.floor((sec%3600)/60);
      const secs=sec%60;

      setText(d, fmt(days));
      setText(h, pad(hrs));
      setText(m, pad(mins));
      setText(s, pad(secs));

      dLbl.textContent = plural(days, "Day", "Days");
      hLbl.textContent = plural(hrs, "Hour", "Hours");
      mLbl.textContent = plural(mins, "Minute", "Minutes");
      sLbl.textContent = plural(secs, "Second", "Seconds");

      setText(th, fmt(Math.floor(sec/3600)));
      setText(tm, fmt(Math.floor(sec/60)));
      setText(ts, fmt(sec));

      milestoneCountdown.textContent = milestoneText(sec);
      applyTheme(sec);

      if (sec <= 3600*24){
        secondsBox.style.borderColor = "rgba(255,120,200,.40)";
      } else if (sec <= 3600*24*7){
        secondsBox.style.borderColor = "rgba(160,255,210,.35)";
      } else {
        secondsBox.style.borderColor = "rgba(190,120,255,.32)";
      }
    }

    function tickSince(){
      let diff = Date.now() - SINCE;
      if(diff < 0) diff = 0;

      const sec = Math.floor(diff/1000);

      const days=Math.floor(sec/86400);
      const hrs=Math.floor((sec%86400)/3600);
      const mins=Math.floor((sec%3600)/60);
      const secs=sec%60;

      setText(sd, fmt(days));
      setText(sh, pad(hrs));
      setText(sm, pad(mins));
      setText(ss, pad(secs));

      sdLbl.textContent = plural(days, "Day", "Days");
      shLbl.textContent = plural(hrs, "Hour", "Hours");
      smLbl.textContent = plural(mins, "Minute", "Minutes");
      ssLbl.textContent = plural(secs, "Second", "Seconds");

      setText(sth, fmt(Math.floor(sec/3600)));
      setText(stm, fmt(Math.floor(sec/60)));
      setText(sts, fmt(sec));

      milestoneSince.textContent = milestoneTextSince(sec);
    }

    function tickAll(){
      tickCountdown();
      tickSince();
    }

    function startStars(){
      const canvas = document.getElementById("stars");
      const ctx = canvas.getContext("2d");
      let w, h, dpr;
      let stars = [];

      function resize(){
        dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        w = canvas.width = Math.floor(window.innerWidth * dpr);
        h = canvas.height = Math.floor(window.innerHeight * dpr);
        canvas.style.width = window.innerWidth + "px";
        canvas.style.height = window.innerHeight + "px";

        const count = Math.floor((window.innerWidth * window.innerHeight) / 18000);
        stars = Array.from({length: Math.max(60, Math.min(160, count))}, () => ({
          x: Math.random() * w,
          y: Math.random() * h,
          r: (Math.random() * 1.4 + 0.4) * dpr,
          a: Math.random() * 0.55 + 0.15,
          vy: (Math.random() * 0.06 + 0.02) * dpr,
          tw: Math.random() * 0.8 + 0.2,
          t: Math.random() * Math.PI * 2,
        }));
      }

      function draw(){
        ctx.clearRect(0,0,w,h);
        for (const s of stars){
          s.t += 0.008 * s.tw;
          const alpha = s.a + Math.sin(s.t) * 0.10;

          ctx.beginPath();
          ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(234,240,255,${Math.max(0, Math.min(0.8, alpha))})`;
          ctx.fill();

          s.y += s.vy;
          if (s.y > h + 10) { s.y = -10; s.x = Math.random() * w; }
        }
        requestAnimationFrame(draw);
      }

      resize();
      window.addEventListener("resize", resize);
      draw();
    }

    startRotator(rotatorCountdown, rotateCountdownLines);
    startRotator(rotatorSince, rotateSinceLines);
    startStars();

    tickAll();
    setInterval(tickAll, 1000);
  </script>
</body>
</html>
